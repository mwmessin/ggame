// Generated by CoffeeScript 1.3.1
(function() {

  this.Level = (function() {

    Level.name = 'Level';

    function Level(_arg) {
      var being, beings, beingspace, element, grid, i, infospace, item, items, name, row, rows, tile, tilespace, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      name = _arg.name, grid = _arg.grid, beings = _arg.beings, items = _arg.items;
      this.name = name;
      this.grid = grid;
      element = this.element = $("<div>", {
        "class": "level"
      });
      tilespace = this.tilespace = $("<div>").addClass("tilespace").appendTo(element);
      beingspace = this.beingspace = $("<div>").addClass("beingspace").appendTo(element);
      infospace = this.infospace = $("<div>").addClass("infospace").appendTo(element);
      rows = grid.length;
      for (i = _i = 0, _len = grid.length; _i < _len; i = ++_i) {
        row = grid[i];
        y = rows - i - 1;
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          tile = row[x];
          if (tile == null) {
            continue;
          }
          extend(tile, game.tiles[tile.name]);
          extend(tile, {
            parent: tilespace,
            location: [x * 24, y * 24]
          });
          row[x] = new Tile(tile);
          this.orientTile(x, y);
        }
      }
      for (_k = 0, _len2 = beings.length; _k < _len2; _k++) {
        being = beings[_k];
        game.engine.add(new Being(union(being, game.beings[being.kind], {
          parent: beingspace
        })));
      }
      for (_l = 0, _len3 = items.length; _l < _len3; _l++) {
        item = items[_l];
        game.engine.add(new Item(union(item, game.items[item.kind], {
          parent: beingspace
        })));
      }
    }

    Level.prototype.save = function() {
      var beings, body, items, row, tile, _i, _len, _ref;
      beings = [];
      items = [];
      _ref = game.engine.system;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        body = _ref[_i];
        if (body.isBeing) {
          beings.push(body.save());
        } else if (body.isItem) {
          items.push(body.save());
        }
      }
      return {
        name: this.name,
        grid: (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.grid;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            row = _ref1[_j];
            _results.push((function() {
              var _k, _len2, _results1;
              _results1 = [];
              for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
                tile = row[_k];
                _results1.push(tile != null ? tile.save() : void 0);
              }
              return _results1;
            })());
          }
          return _results;
        }).call(this),
        beings: beings,
        items: items
      };
    };

    Level.prototype.collide = function(object, width, height) {
      var dx, dx1, dx2, dy, dy1, dy2, row, x, x1, x2, y, y1, y2, _i, _ref, _ref1, _results;
      if (width == null) {
        width = 24;
      }
      if (height == null) {
        height = 24;
      }
      x1 = object.x1, x2 = object.x2, y1 = object.y1, y2 = object.y2;
      _results = [];
      for (y = _i = _ref = y1 / height | 0, _ref1 = y2 / height | 0; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        row = this.grid[this.grid.length - y - 1];
        if (row) {
          _results.push((function() {
            var _j, _ref2, _ref3, _ref4, _results1;
            _results1 = [];
            for (x = _j = _ref2 = x1 / width | 0, _ref3 = x2 / width | 0; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
              if (((_ref4 = row[x]) != null ? _ref4.z : void 0) > object.z) {
                dx1 = x1 - (x + 1) * width;
                dx2 = x2 - x * width;
                dy1 = y1 - (y + 1) * height;
                dy2 = y2 - y * height;
                dx = (Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2);
                dy = (Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2);
                if (Math.abs(dx) < Math.abs(dy)) {
                  _results1.push(object.move(new Vector2(-dx, 0)));
                } else {
                  _results1.push(object.move(new Vector2(0, -dy)));
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.tile = function(x, y) {
      var grid, row, tile;
      if (x < 0 || y < 0) {
        return null;
      }
      grid = this.grid;
      row = grid[grid.length - y - 1];
      tile = (row ? row[x] : null);
      if (tile && tile.isTile) {
        return tile;
      } else {
        return null;
      }
    };

    Level.prototype.elevation = function(x, y, z) {
      var b, bl, br, l, r, t, tile, tl, tr, _ref;
      tile = this.tile(x, y);
      if (z === null) {
        return tile.z;
      }
      tile.z = z;
      _ref = [this.tile(x - 1, y + 1) || {}, this.tile(x, y + 1) || {}, this.tile(x + 1, y + 1) || {}, this.tile(x - 1, y) || {}, tile, this.tile(x + 1, y) || {}, this.tile(x - 1, y - 1) || {}, this.tile(x, y - 1) || {}, this.tile(x + 1, y - 1) || {}], tl = _ref[0], t = _ref[1], tr = _ref[2], l = _ref[3], tile = _ref[4], r = _ref[5], bl = _ref[6], b = _ref[7], br = _ref[8];
      if (l.z < z - 1) {
        this.elevation(x - 1, y, z - 1);
      }
      if (l.z > z + 1) {
        this.elevation(x - 1, y, z + 1);
      }
      if (r.z < z - 1) {
        this.elevation(x + 1, y, z - 1);
      }
      if (r.z > z + 1) {
        this.elevation(x + 1, y, z + 1);
      }
      if (bl.z < z - 1) {
        this.elevation(x - 1, y - 1, z - 1);
      }
      if (bl.z > z + 1) {
        this.elevation(x - 1, y - 1, z + 1);
      }
      if (b.z < z - 1) {
        this.elevation(x, y - 1, z - 1);
      }
      if (b.z > z + 1) {
        this.elevation(x, y - 1, z + 1);
      }
      if (br.z < z - 1) {
        this.elevation(x + 1, y - 1, z - 1);
      }
      if (br.z > z + 1) {
        this.elevation(x + 1, y - 1, z + 1);
      }
      return this.orientTile(x, y);
    };

    Level.prototype.removeTile = function(x, y) {
      var tile;
      tile = this.tile(x, y);
      game.engine.remove(tile);
      return this.grid[y][x] = null;
    };

    Level.prototype.orientTile = function(x, y, noRecurse) {
      var b, bl, bottom, br, l, left, name, orientation, r, right, t, tile, tl, top, tr, tt, ttl, ttr, z, _ref;
      tile = this.tile(x, y);
      if (!(tile != null)) {
        return;
      }
      name = tile.name, z = tile.z;
      _ref = [this.tile(x - 1, y + 2) || {}, this.tile(x, y + 2) || {}, this.tile(x + 1, y + 2) || {}, this.tile(x - 1, y + 1) || {}, this.tile(x, y + 1) || {}, this.tile(x + 1, y + 1) || {}, this.tile(x - 1, y) || {}, tile, this.tile(x + 1, y) || {}, this.tile(x - 1, y - 1) || {}, this.tile(x, y - 1) || {}, this.tile(x + 1, y - 1) || {}], ttl = _ref[0], tt = _ref[1], ttr = _ref[2], tl = _ref[3], t = _ref[4], tr = _ref[5], l = _ref[6], tile = _ref[7], r = _ref[8], bl = _ref[9], b = _ref[10], br = _ref[11];
      top = t.z >= z && t.name === name;
      left = l.z >= z && l.name === name;
      right = r.z >= z && r.name === name;
      bottom = b.z >= z && b.name === name;
      orientation = "normal";
      if (top && left && bottom && right) {
        orientation = "normal";
      }
      if (top && left && bottom && !right) {
        orientation = "right";
      }
      if (top && left && !bottom && right) {
        orientation = "bottom";
      }
      if (top && !left && bottom && right) {
        orientation = "left";
      }
      if (!top && !left && bottom && right) {
        orientation = "normal";
      }
      if (!top && left && bottom && !right) {
        orientation = "normal";
      }
      if (top && left && !bottom && !right) {
        orientation = "bottomright";
      }
      if (top && !left && !bottom && right) {
        orientation = "bottomleft";
      }
      if (top && !left && bottom && !right) {
        orientation = "vertical";
      }
      if (top && !left && !bottom && !right) {
        orientation = "tipbottom";
      }
      if (!top && !left && bottom && !right) {
        orientation = "normal";
      }
      if (!top && !left && !bottom && right) {
        orientation = "normal";
      }
      if (!top && left && !bottom && !right) {
        orientation = "normal";
      }
      if (!top && !left && !bottom && !right) {
        orientation = "normal";
      }
      if (t.z > z && tt.z <= z && tl.z <= z && tr.z <= z) {
        orientation += " column";
      }
      if (t.z > z && tt.z <= z && tr.z > z && tl.z <= z) {
        orientation += " columnleft";
      }
      if (t.z > z && tt.z <= z && tl.z > z && tr.z <= z) {
        orientation += " columnright";
      }
      if (tl.z > z && t.z > z && tr.z > z || tt.z > z && tl.z <= z && t.z > z && tr.z <= z) {
        orientation += " wall";
      }
      if (tt.z > z && tl.z <= z && t.z > z && tr.z > z) {
        orientation += " wallleft";
      }
      if (tt.z > z && tl.z > z && t.z > z && tr.z <= z) {
        orientation += " wallright";
      }
      if (ttr.z > t.z && tr.z > t.z && (tl.z <= t.z || ttl.z <= t.z)) {
        orientation += " wallbottomleft";
      }
      if (ttl.z > t.z && tl.z > t.z && (tr.z <= t.z || ttr.z <= t.z)) {
        orientation += " wallbottomright";
      }
      if (ttl.z > t.z && ttr.z > t.z && tl.z > t.z && tr.z > t.z) {
        orientation += " cheeks";
      }
      if (tr.z > z && r.z > z && (l.z <= z || tl.z <= z)) {
        orientation += " slopeleft";
      }
      if (tl.z > z && l.z > z && (r.z <= z || tr.z <= z)) {
        orientation += " sloperight";
      }
      if (tl.z > z && tr.z > z && l.z > z && r.z > z) {
        orientation += " twinpeaks";
      }
      if (t.z < z && l.z > t.z && b.z > t.z && r.z > t.z) {
        orientation += " top";
      }
      if (!top && left && !bottom && right) {
        orientation += " horizontal";
      }
      if (!top && !left && bottom && right) {
        orientation += " topleft";
      }
      if (!top && left && bottom && !right) {
        orientation += " topright";
      }
      if (!top && !left && !bottom && right) {
        orientation += " tipleft";
      }
      if (!top && left && !bottom && !right) {
        orientation += " tipright";
      }
      if (!top && !left && bottom && !right) {
        orientation += " tiptop";
      }
      if (!top && !left && !bottom && !right) {
        orientation += " island";
      }
      tile.orient(orientation);
      if (!noRecurse) {
        this.orientTile(x, y + 1, true);
        this.orientTile(x + 1, y, true);
        this.orientTile(x, y - 1, true);
        this.orientTile(x - 1, y, true);
        this.orientTile(x - 1, y - 1, true);
        this.orientTile(x + 1, y - 1, true);
        this.orientTile(x - 1, y - 2, true);
        this.orientTile(x, y - 2, true);
        return this.orientTile(x + 1, y - 2, true);
      }
    };

    Level.prototype.generateTerrain = function(order) {
      var average, col, factor, grid, half, length, random, segments, terrain, x, y, z, _i, _j, _k, _l, _len, _len1;
      if (order == null) {
        order = 1;
      }
      segments = Math.pow(2, order);
      grid = [];
      for (x = _i = 0; 0 <= segments ? _i <= segments : _i >= segments; x = 0 <= segments ? ++_i : --_i) {
        col = grid[x] = [];
        for (y = _j = 0; 0 <= segments ? _j <= segments : _j >= segments; y = 0 <= segments ? ++_j : --_j) {
          col[y] = 0.0;
        }
      }
      random = function(factor) {
        return (Math.random() - 0.5) * 2 * factor;
      };
      factor = 1;
      length = segments;
      while (length >= 2) {
        half = length / 2;
        y = 0;
        while (y < segments) {
          x = 0;
          while (x < segments) {
            average = (grid[y][x] + grid[y + length][x] + grid[y][x + length] + grid[y + length][x + length]) / 4;
            grid[y + half][x + half] = average + random(factor);
            x += length;
          }
          y += length;
        }
        y = half;
        while (y < segments) {
          x = half;
          while (x < segments) {
            if (y === half) {
              average = (grid[(y - length + segments) % segments][x] + grid[y - half][x + half] + grid[y][x] + grid[y - half][x - half]) / 4;
              grid[y - half][x] = average + random(factor);
            }
            average = (grid[y - half][x + half] + grid[y][(x + length + segments) % segments] + grid[y + half][x + half] + grid[y][x]) / 4;
            grid[y][x + half] = average + random(factor);
            average = (grid[y][x] + grid[y + half][x + half] + grid[(y + length + segments) % segments][x] + grid[y + half][x - half]) / 4;
            grid[y + half][x] = average + random(factor);
            if (x === half) {
              average = (grid[y - half][x - half] + grid[y][x] + grid[y + half][x - half] + grid[y][(x - length + segments) % segments]) / 4;
              grid[y][x - half] = average + random(factor);
            }
            x += length;
          }
          y += length;
        }
        length /= 2;
        factor /= 2;
      }
      terrain = [];
      for (x = _k = 0, _len = grid.length; _k < _len; x = ++_k) {
        col = grid[x];
        terrain[x] = [];
        for (y = _l = 0, _len1 = col.length; _l < _len1; y = ++_l) {
          z = col[y];
          terrain[x][y] = {
            name: 'dirt',
            z: z
          };
        }
      }
      return terrain;
    };

    Level.prototype.canvasTerrain = function(terrain) {
      var canvas, context, data, frame, setPixel, v, width, x, y, _i, _j, _ref;
      width = terrain.length;
      $("body").append(canvas = $("<canvas>", {
        css: {
          border: "1px solid green"
        }
      }).attr({
        width: width,
        height: width
      }));
      context = canvas[0].getContext("2d");
      frame = (_ref = context.getImageData(0, 0, width, width), data = _ref.data, _ref);
      setPixel = function(x, y, r, g, b, a) {
        var index;
        index = (x + y * width) * 4;
        data[index + 0] = r;
        data[index + 1] = g;
        data[index + 2] = b;
        return data[index + 3] = a;
      };
      for (x = _i = 0; 0 <= width ? _i < width : _i > width; x = 0 <= width ? ++_i : --_i) {
        for (y = _j = 0; 0 <= width ? _j < width : _j > width; y = 0 <= width ? ++_j : --_j) {
          v = (terrain[x][y].z + 1) / 2 * 255 | 0;
          setPixel(x, y, v, v, v, 255);
        }
      }
      return context.putImageData(frame, 0, 0);
    };

    Level.prototype.logTerrain = function(terrain) {
      var msg, x, y, _i, _j, _len, _len1, _results;
      _results = [];
      for (_i = 0, _len = terrain.length; _i < _len; _i++) {
        x = terrain[_i];
        msg = "";
        for (_j = 0, _len1 = x.length; _j < _len1; _j++) {
          y = x[_j];
          msg += y.z.toFixed(2) + " ";
        }
        _results.push(console.log(msg));
      }
      return _results;
    };

    return Level;

  })();

}).call(this);
